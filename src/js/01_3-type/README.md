- 원시값 변경 시 실제로 무엇이 일어나는지?

  - 원시값이 일단 뭐가 있는지 확인해봐야할거같아
  - 내가 현재 익숙한 원시값은: string, number, boolean, null, undefined 정도야
    - 추가적으로 확인 가능한게: symbol, bigint가 존재하네
  - 이들의 특징이 뭘까?
    - 원시값이 아닌 값들이랑 여러가지 상황을 비교해보면 특징이 부각될거같아
      - 원시값과 참조값 둘 다 복사후에 원본을 변경하는 상황을 보면
        - 원시값은 복사값은 유지되지만 참조값은 복사값도 바뀌네
        - 아마 참조값은 하나의 메모리 주소를 같이 참조하고 있는 상황이고, 원시값은 복사라하더라도 아예 다른 메모리 주소를 할당받을니까 이런 결과가 나올꺼야

- 객체(배열, 함수 포함)는 어떻게 참조가 전달되는지?

  - 참조값은 값 자체를 전달되는게 아니라 해당 값에 대한 정보가 전달되는거 같아
  - 예를들어 `const a = {age: 30}; const b = a` 이건 {age: 30}이라는 값이 b로 할당되는게 아니라 a라는 변수에 대한 정보가 전달될꺼야
    하나의 **공동 계좌(객체)** 를 떠올려봅시다.

1. `const a = { age: 30 };`

   - “공동 계좌를 만들고, 그 안에 현재 30만 원(age=30) 있다는 정보를 기록했다”고 생각하세요.
   - 지금 이 계좌를 가리키는 ‘통장(a)’이 발급된 상황입니다.

2. `let b = a;`

   - 이제 똑같은 공동 계좌를 가리키는 또 다른 통장(b)을 만들었습니다.
   - 통장 겉면은 달라도, **속한 계좌(실제 데이터)** 는 둘 다 동일합니다.

3. `b.age = 40;`

   - b 통장을 통해 **공동 계좌에 돈을 40만 원으로 변경**해버린 겁니다.
   - 이 시점에서 실제 계좌에는 40만 원이 있다는 기록으로 바뀌어요.

4. `console.log(a.age);` / `console.log(b.age);`

   - a 통장에서 확인해도 40만 원, b 통장에서 확인해도 40만 원이 찍히죠.
   - **왜냐하면 둘 다 ‘같은 계좌 정보(동일 객체)’를 공유**하고 있기 때문입니다.

5. `console.log(a.age === b.age);`
   - 당연히 같으니 `true`가 나옵니다.
   - a와 b는 전혀 다른 ‘종이 다른 통장’처럼 보이지만, **궁극적으로는 같은 공동 계좌**를 참조하니까요.

---

### 핵심 요점

- `a`와 `b`가 서로 다른 변수처럼 보여도, 실제로는 **같은 객체(공동 계좌)** 를 가리키고 있습니다.
- 따라서 한 쪽에서 ‘나이(age)’를 바꾸면, 다른 쪽에서도 그 바뀐 값을 그대로 보게 됩니다.

- 0, NaN, "", null, undefined 등이 어떤 상황에서 문제를 일으키는지?
- 객체({}, [])는 왜 항상 truthy인지?

- [] == false, [] == ![], null == undefined 등의 예시 직접 실행해보기
- 예측과 실제 결과가 어떻게 다른지 체크해보면 재밌습니다.

- 다양한 자료형을 String(), Number(), Boolean()으로 바꿔서 콘솔에 찍어보기
- "123"이나 " 123 " 같은 문자열을 숫자로 변환하면 무엇이 되는지?
- 그 결과는 언제 NaN(숫자가 아님)이 되는지?
